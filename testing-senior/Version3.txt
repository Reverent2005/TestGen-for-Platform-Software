import java.util.*;

// Equivalent to: #pragma once
// C++ uses unique_ptr, Java uses references and garbage collection.

// Assume: Expr, Var, Num, SetExpr, MapExpr, TupleExpr, FuncCall, FuncCallStmt, SymbolTable, TypeMap, FunctionSpec, Program are already defined.

public class Version3 {

    // linear
    public static Expr convert1(Expr expr, SymbolTable symtable, String add) {
        if (expr == null) {
            return null;
        }

        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (symtable.exists(var.name)) {
                return new Var(var.name + add);
            }
            return new Var(var.name);
        }

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            List<Expr> args = new ArrayList<>();
            for (Expr arg : func.args) {
                args.add(convert1(arg, symtable, add));
            }
            return new FuncCall(func.name, args);
        }

        if (expr instanceof Num) {
            Num num = (Num) expr;
            return new Num(num.value);
        }

        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            List<Expr> elements = new ArrayList<>();
            for (Expr element : set.elements) {
                elements.add(convert1(element, symtable, add));
            }
            return new SetExpr(elements);
        }

        if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            List<Pair<Var, Expr>> ret = new ArrayList<>();
            for (Pair<Var, Expr> entry : map.entries) {
                Var key = (Var) convert1(entry.key, symtable, add); // Ensure this cast is safe!
                Expr value = convert1(entry.value, symtable, add);
                ret.add(new Pair<>(key, value));
            }
            return new MapExpr(ret);
        }

        if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            List<Expr> exprs = new ArrayList<>();
            for (Expr exp : tuple.elements) {
                exprs.add(convert1(exp, symtable, add));
            }
            return new TupleExpr(exprs);
        }

        // throw new RuntimeException("Unknown expression type in convert1 function");
        return null;
    }

    public static void addthedashexpr(Expr expr, Set<String> res) {
        if (expr == null) return;

        if (expr instanceof Var) {
            return;
        }
        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            if (func.name.equals("'")) {
                Expr v = func.args.get(0);
                if (v instanceof Var) {
                    res.add(((Var) v).name);
                }
            } else {
                for (Expr arg : func.args) {
                    addthedashexpr(arg, res);
                }
            }
            return;
        }
        if (expr instanceof Num) {
            return;
        }
        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            for (Expr element : set.elements) {
                addthedashexpr(element, res);
            }
            return;
        }
        if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            for (Pair<Var, Expr> entry : map.entries) {
                addthedashexpr(entry.key, res);
                addthedashexpr(entry.value, res);
            }
            return;
        }
        if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            for (Expr exp : tuple.elements) {
                addthedashexpr(exp, res);
            }
            return;
        }
    }

    public static Expr removethedashexpr(Expr expr, Set<String> res, int flag) {
        if (expr == null) return null;

        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (flag != 0) {
                return new Var(var.name);
            } else if (flag == 0 && res.contains(var.name)) {
                return new Var(var.name + "_old");
            } else {
                return new Var(var.name);
            }
        }

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            if (func.name.equals("'")) {
                return removethedashexpr(func.args.get(0), res, 1);
            }
            List<Expr> args = new ArrayList<>();
            for (Expr arg : func.args) {
                args.add(removethedashexpr(arg, res, 0));
            }
            return new FuncCall(func.name, args);
        }

        if (expr instanceof Num) {
            return new Num(((Num) expr).value);
        }

        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            List<Expr> elements = new ArrayList<>();
            for (Expr element : set.elements) {
                elements.add(removethedashexpr(element, res, 0));
            }
            return new SetExpr(elements);
        }

        if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            List<Pair<Var, Expr>> ret = new ArrayList<>();
            for (Pair<Var, Expr> entry : map.entries) {
                Var key = (Var) removethedashexpr(entry.key, res, 0);
                Expr value = removethedashexpr(entry.value, res, 0);
                ret.add(new Pair<>(key, value));
            }
            return new MapExpr(ret);
        }

        if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            List<Expr> exprs = new ArrayList<>();
            for (Expr exp : tuple.elements) {
                exprs.add(removethedashexpr(exp, res, 0));
            }
            return new TupleExpr(exprs);
        }

        throw new RuntimeException("Unknown expression type in removethedashexpr function");
    }

    public static FuncCallStmt makeStmt(Expr expr) {
        if (expr instanceof Var) {
            Var call = (Var) expr;
            List<Expr> args = new ArrayList<>();
            args.add(new Var(call.name));
            FuncCall h = new FuncCall("input", args);
            return new FuncCallStmt(h);
        }
        return null;
    }

    public static void getInputVars(Expr expr, List<Expr> inputVariables, String toadd, SymbolTable symtable, TypeMap finalMapExpr, TypeMap typeMapExpr) {
        if (expr == null) return;

        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (symtable.exists(var.name)) {
                if (typeMapExpr.mapping.containsKey(var.name)) {
                    Type type = typeMapExpr.mapping.get(var.name);
                    finalMapExpr.mapping.put(var.name + toadd, type);
                }
            }
            inputVariables.add(convert1(expr, symtable, toadd));
            return;
        }
        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            for (Expr arg : func.args) {
                getInputVars(arg, inputVariables, toadd, symtable, finalMapExpr, typeMapExpr);
            }
            return;
        }
        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            for (Expr element : set.elements) {
                getInputVars(element, inputVariables, toadd, symtable, finalMapExpr, typeMapExpr);
            }
            return;
        }
        if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            for (Expr exp : tuple.elements) {
                getInputVars(exp, inputVariables, toadd, symtable, finalMapExpr, typeMapExpr);
            }
            return;
        }
        if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            for (Pair<Var, Expr> entry : map.entries) {
                getInputVars(entry.key, inputVariables, toadd, symtable, finalMapExpr, typeMapExpr);
                getInputVars(entry.value, inputVariables, toadd, symtable, finalMapExpr, typeMapExpr);
            }
            return;
        }
        if (expr instanceof Num) {
            return;
        }
    }
    
    // Main program synthesizer function
    // FunctionSpec replaces Spec, FuncCalls replaces APICalls
    public static Program convert(Specification funcSpec, SymbolTable symtable, TypeMap typeMap) {
        TypeMap finaltm = new TypeMap();
        List<Stmt> program_stmts = new ArrayList<>();
        
        for (int i = 0; i < funcSpec.blocks.size(); i++) {
            TypeMap itm = new TypeMap();
            SymbolTable currtable = symtable.children.get(i);
            FunctionSpec currblock = funcSpec.blocks.get(i);
            Expr pre = currblock.pre;
            FuncCall call = currblock.call.call;
            Response response = currblock.response;
            Expr post = response.expr;

            List<Expr> inputVariables = new ArrayList<>();
            for (Expr arg : call.args) {
                getInputVars(arg, inputVariables, Integer.toString(i), currtable, finaltm, itm);
            }

            for (Expr inputVar : inputVariables) {
                program_stmts.add(makeStmt(inputVar));
            }

            Expr pre1 = convert1(pre, currtable, Integer.toString(i));
            FuncCall callExpr = new FuncCall(call.name, call.args);
            Expr call1 = convert1(callExpr, currtable, Integer.toString(i));
            Expr post1 = convert1(post, currtable, Integer.toString(i));

            Set<String> res = new HashSet<>();
            addthedashexpr(post1, res);

            List<Expr> v1 = new ArrayList<>(); v1.add(pre1);
            FuncCall assumeCall = new FuncCall("assume", v1);
            program_stmts.add(new FuncCallStmt(assumeCall));

            for (String s : res) {
                program_stmts.add(makeStmt(new Var(s + "_old")));
                List<Expr> v = new ArrayList<>();
                v.add(new Var(s + "_old"));
                v.add(new Var(s));
                FuncCall assignDash = new FuncCall("=", v);
                program_stmts.add(new FuncCallStmt(assignDash));
            }

            program_stmts.add(new FuncCallStmt((FuncCall) call1));
            post1 = removethedashexpr(post1, res, 0);

            List<Expr> v2 = new ArrayList<>(); v2.add(post1);
            FuncCall assertCall = new FuncCall("assert", v2);
            program_stmts.add(new FuncCallStmt(assertCall));
        }
        return new Program(program_stmts);
    }
}
