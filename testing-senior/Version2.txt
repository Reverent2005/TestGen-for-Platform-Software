import java.util.*;
// ===================================
// Main Algorithm Logic
// ===================================

public class Version2 {

    /**
     * Recursively creates a deep copy of an expression tree, renaming local variables by appending a suffix.
     * This isolates variables within the context of a single function call.
     *
     * @param expr The expression to transform.
     * @param symtable The symbol table for the current scope, containing local variables.
     * @param suffix The string to append to local variable names (e.g., "0", "1").
     * @return A new, transformed expression tree.
     */
    public static Expr convert1(final Expr expr, final SymbolTable symtable, final String suffix) {
        if (expr == null) return null;

        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (symtable.exists(var.name)) {
                return new Var(var.name + suffix);
            }
            return new Var(var.name);
        }

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            List<Expr> newArgs = new ArrayList<>();
            for (Expr arg : func.args) {
                newArgs.add(convert1(arg, symtable, suffix));
            }
            return new FuncCall(func.name, newArgs);
        }

        if (expr instanceof Num) {
            Num num = (Num) expr;
            return new Num(num.value);
        }

        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            List<Expr> newElements = new ArrayList<>();
            for (Expr element : set.elements) {
                newElements.add(convert1(element, symtable, suffix));
            }
            return new SetExpr(newElements);
        }
        
        if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            List<Pair<Var, Expr>> newEntries = new ArrayList<>();
            for (Pair<Var, Expr> entry : map.entries) {
                // In Java, Var is a subclass of Expr, so no cast is needed. This is much cleaner.
                Var newKey = (Var) convert1(entry.key, symtable, suffix);
                Expr newValue = convert1(entry.value, symtable, suffix);
                newEntries.add(new Pair<>(newKey, newValue));
            }
            return new MapExpr(newEntries);
        }

        if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            List<Expr> newElements = new ArrayList<>();
            for (Expr element : tuple.elements) {
                newElements.add(convert1(element, symtable, suffix));
            }
            return new TupleExpr(newElements);
        }

        throw new RuntimeException("Unknown expression type in convert1 function");
    }

    /**
     * Finds all variables marked with a "dash" (e.g., 'U) and adds their base name to a set.
     * The dash is represented as a function call with the name "'".
     *
     * @param expr The expression to scan.
     * @param result An output set to store the names of dashed variables.
     */
    public static void findDashedVariables(final Expr expr, final Set<String> result) {
        if (expr == null) return;

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            if ("'".equals(func.name) && func.args.size() > 0 && func.args.get(0) instanceof Var) {
                Var var = (Var) func.args.get(0);
                result.add(var.name);
            } else {
                for (Expr arg : func.args) {
                    findDashedVariables(arg, result);
                }
            }
        } else if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            for (Expr element : set.elements) {
                findDashedVariables(element, result);
            }
        } else if (expr instanceof MapExpr) {
            MapExpr map = (MapExpr) expr;
            for (Pair<Var, Expr> entry : map.entries) {
                findDashedVariables(entry.key, result);
                findDashedVariables(entry.value, result);
            }
        } else if (expr instanceof TupleExpr) {
            TupleExpr tuple = (TupleExpr) expr;
            for (Expr element : tuple.elements) {
                findDashedVariables(element, result);
            }
        }
    }

    /**
     * Transforms a post-condition expression by removing the dash notation ('U becomes U)
     * and renaming original state variables to their "_old" version (U becomes U_old).
     *
     * @param expr The expression to transform.
     * @param dashedVars A set containing the names of variables that need transformation.
     * @param isUnderDash A flag to track if we are currently inside a dash ('(...)) call.
     * @return A new, transformed expression tree.
     */
    public static Expr transformDashedExpr(final Expr expr, final Set<String> dashedVars, boolean isUnderDash) {
        if (expr == null) return null;

        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (isUnderDash) {
                return new Var(var.name); // 'U -> U
            } else if (dashedVars.contains(var.name)) {
                return new Var(var.name + "_old"); // U -> U_old
            }
            return new Var(var.name);
        }

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            if ("'".equals(func.name)) {
                return transformDashedExpr(func.args.get(0), dashedVars, true);
            }
            List<Expr> newArgs = new ArrayList<>();
            for (Expr arg : func.args) {
                newArgs.add(transformDashedExpr(arg, dashedVars, isUnderDash));
            }
            return new FuncCall(func.name, newArgs);
        }

        if (expr instanceof Num) {
            Num num = (Num) expr;
            return new Num(num.value);
        }

        if (expr instanceof SetExpr) {
            SetExpr set = (SetExpr) expr;
            List<Expr> newElements = new ArrayList<>();
            for (Expr element : set.elements) {
                newElements.add(transformDashedExpr(element, dashedVars, isUnderDash));
            }
            return new SetExpr(newElements);
        }
        
        // Similar logic for Map and Tuple
        // ... (omitted for brevity, but follows the same pattern as SetExpr)

        throw new RuntimeException("Unknown expression type in transformDashedExpr function");
    }

    /**
     * Creates a statement of the form `input(variable)`.
     */
    public static FuncCallStmt createInputStatement(final Expr expr) {
        if (expr instanceof Var) {
            Var var = (Var) expr;
            List<Expr> args = new ArrayList<>();
            args.add(new Var(var.name));
            FuncCall call = new FuncCall("input", args);
            return new FuncCallStmt(call);
        }
        return null;
    }

    /**
     * Recursively traverses an expression to find all input variables declared in the local symbol table.
     */
    public static void collectInputVariables(final Expr expr, List<Expr> inputVariables, final String suffix,
                                             final SymbolTable symtable, TypeMap finalTypeMap, final TypeMap localTypeMap) {
        if (expr == null) return;
        
        if (expr instanceof Var) {
            Var var = (Var) expr;
            if (symtable.exists(var.name)) {
                Type type = localTypeMap.mapping.get(var.name);
                if (type != null) {
                    finalTypeMap.mapping.put(var.name + suffix, type);
                }
            }
            // The original C++ code adds ALL variables found in the arguments, not just local ones.
            // We replicate that behavior here.
            inputVariables.add(convert1(expr, symtable, suffix));
            return;
        }

        if (expr instanceof FuncCall) {
            FuncCall func = (FuncCall) expr;
            for (Expr arg : func.args) {
                collectInputVariables(arg, inputVariables, suffix, symtable, finalTypeMap, localTypeMap);
            }
        }
        // ... (similar recursive calls for Set, Map, Tuple)
    }

    /**
     * Main conversion function that translates a high-level specification into a verifiable program.
     */
    public static Program convertSpecification(final Specification spec, final SymbolTable globalSymtable, TypeMap globalTypemap) {
        List<Stmt> programStmts = new ArrayList<>();
        
        for (int i = 0; i < spec.blocks.size(); i++) {
            FunctionSpec currentBlock = spec.blocks.get(i);
            SymbolTable currentSymtable = globalSymtable.children.get(i);
            // Assume a local typemap exists, for simplicity
            TypeMap localTypemap = new TypeMap(); 

            // 1. Handle Input Variables
            List<Expr> inputVariables = new ArrayList<>();
            for (Expr arg : currentBlock.call.call.args) {
                collectInputVariables(arg, inputVariables, String.valueOf(i), currentSymtable, globalTypemap, localTypemap);
            }
            for (Expr inputVar : inputVariables) {
                programStmts.add(createInputStatement(inputVar));
            }

            // 2. Rename variables in pre-condition, call, and post-condition
            String suffix = String.valueOf(i);
            Expr preRenamed = convert1(currentBlock.pre, currentSymtable, suffix);
            Expr callRenamed = convert1(currentBlock.call.call, currentSymtable, suffix);
            Expr postRenamed = convert1(currentBlock.response.expr, currentSymtable, suffix);

            // 3. Generate `assume` for the pre-condition
            FuncCall assumeCall = new FuncCall("assume", Collections.singletonList(preRenamed));
            programStmts.add(new FuncCallStmt(assumeCall));

            // 4. Find dashed variables and save their state
            Set<String> dashedVars = new HashSet<>();
            findDashedVariables(postRenamed, dashedVars);
            for (String varName : dashedVars) {
                // Equivalent to `var_old = var`
                FuncCall saveStateCall = new FuncCall("=", Arrays.asList(new Var(varName + "_old"), new Var(varName)));
                programStmts.add(new FuncCallStmt(saveStateCall));
            }

            // 5. Add the actual (renamed) function call
            programStmts.add(new FuncCallStmt((FuncCall) callRenamed));

            // 6. Transform the post-condition and generate `assert`
            Expr postTransformed = transformDashedExpr(postRenamed, dashedVars, false);
            FuncCall assertCall = new FuncCall("assert", Collections.singletonList(postTransformed));
            programStmts.add(new FuncCallStmt(assertCall));
        }

        return new Program(programStmts);
    }
}