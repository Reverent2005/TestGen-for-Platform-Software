# Generated ATC Test Cases for JPF/SPF

This folder contains the generated Abstract Test Cases (ATC) from the ATC algorithm, ready to be used with Java PathFinder (JPF) and Symbolic PathFinder (SPF).

## Folder Structure

```
genoutput/
├── in/ac/iiitb/plproject/atc/generated/
│   ├── GeneratedATCs.java    # Main test class with generated test methods
│   └── Helper.java           # Helper class with methods under test
├── GeneratedATCs_increment_helper.jpf    # JPF config for increment test
├── GeneratedATCs_process_helper.jpf     # JPF config for process test
└── README.md                 # This file
```

## Files Description

### GeneratedATCs.java
The main test class generated by the ATC algorithm. It contains:
- `increment_helper()` - Test method for the increment function
- `process_helper()` - Test method for the process function
- `main()` - Entry point that runs all test methods

### Helper.java
Helper class containing the actual methods being tested:
- `increment(int x)` - Increments an integer value
- `process(Set data, Map result)` - Processes data and updates result map
- `update(Map result, Set data)` - Helper function for postcondition verification

### .jpf Files
JPF configuration files for running symbolic execution:
- **`GeneratedATCs_main.jpf`** - **PRIMARY TEST FILE** - Configuration for testing the complete sequence in main() method. This runs the full test sequence from the test string (e.g., [increment, increment, process, increment]).
- `GeneratedATCs_increment_helper.jpf` - Configuration for testing increment_helper() individually (for debugging)
- `GeneratedATCs_process_helper.jpf` - Configuration for testing process_helper() individually (for debugging)

## How to Use

### 1. Copy to SPF Examples Directory

Copy this entire `genoutput` folder to your JPF-SPBC examples directory:
```bash
cp -r genoutput ${jpf-symbc}/src/examples/
```

Or on Windows:
```cmd
xcopy /E /I genoutput %JPF_SYMBC%\src\examples\genoutput
```

### 2. Compile the Java Files

Navigate to the JPF-SPBC build directory and compile:
```bash
cd ${jpf-symbc}/build/examples
javac -cp . in/ac/iiitb/plproject/atc/generated/*.java
```

### 3. Run JPF with a Configuration File

**Primary Test (Recommended):** Run JPF using the main .jpf file to test the complete sequence:
```bash
cd ${jpf-symbc}
bin/jpf GeneratedATCs_main.jpf
```

This will test the `main()` method which contains the full test sequence from your test string.

**Individual Method Tests (Optional):** For debugging individual methods:
```bash
bin/jpf GeneratedATCs_increment_helper.jpf
```

Or:
```bash
bin/jpf GeneratedATCs_process_helper.jpf
```

### 4. Expected Output and Extracting Test Inputs

JPF will:
- Execute the test method symbolically
- Explore all possible execution paths
- Generate concrete test inputs that satisfy the path conditions
- Report any assertion violations or errors

#### How to Extract Concrete Test Input Values

The JPF output contains concrete test inputs in several places:

1. **Path Conditions (pc)**: Look for lines like:
   ```
   pc 1 constraint # = 1
   x > CONST_0
   ```
   This shows the path condition that was explored.

2. **JUnit Test Class Section**: The most important section for test inputs:
   ```
   ====================================================== JUnit 4.0 test class
   
   @Test
   public void test0() {
       in_ac_iiitb_plproject_atc_generated_generatedatcs.main([Ljava.lang.String;@bb);
   }
   ```
   This shows the concrete test case, but the actual values are in the path conditions above.

3. **Method Sequences**: Shows the execution sequence:
   ```
   ====================================================== Method Sequences
   [main([Ljava.lang.String;@bb)]
   ```
   The concrete values that satisfy the path conditions are determined by the constraint solver.

4. **To Get Actual Concrete Values**: 
   - The path conditions (pc) show the constraints
   - JPF's constraint solver finds values that satisfy these constraints
   - For example, if `pc 1` shows `x > 0`, JPF will find a concrete value like `x = 1` or `x = 42` that satisfies this
   - The actual concrete values are embedded in the execution - you may need to add print statements or use JPF's concrete value extraction features

**Note**: For more detailed concrete value extraction, you can:
- Add `System.out.println()` statements in your test code to print symbolic variable values
- Use JPF's `Debug.printPC()` to print path conditions with concrete solutions
- Check the JPF output for "constraint" sections which show the solved values

## Test Cases

### main() - Complete Test Sequence
- **Test Sequence**: Runs the full sequence from the test string (e.g., `[increment, increment, process, increment]`)
- **Purpose**: Tests the complete interaction between function calls in the specified order
- **This is the primary test** that should be run with JPF to generate concrete test inputs for the entire sequence

### increment_helper()
- **Precondition**: `x > 0`
- **Postcondition**: `x > x_old` (value after call is greater than before)
- **Symbolic Variable**: `x` (integer)
- **Note**: Individual test method, use for debugging specific functions

### process_helper()
- **Precondition**: `new Set(1, 2, 3).contains(2)`
- **Postcondition**: `result == update(result_old, data_old)`
- **Symbolic Variables**: `data` (Set), `result` (Map) - **Now uses symbolic execution!**
- **Note**: Individual test method, use for debugging specific functions
- **Symbolic Collections**: Collections are now initialized using `Debug.makeSymbolicRef()` with empty collections as defaults, allowing JPF to explore different collection states symbolically

## Notes

- The generated code uses `gov.nasa.jpf.symbc.Debug` for symbolic execution
- **Primitive types** (int, double, String, boolean) use `Debug.makeSymbolicInteger()`, `Debug.makeSymbolicDouble()`, etc.
- **Collections** (Set, Map, List) use `Debug.makeSymbolicRef()` with empty collection instances as defaults (e.g., `new HashSet<>()`) to enable symbolic execution while avoiding null pointer issues
- **Custom classes** use `Debug.makeSymbolicRef()` with appropriate default values
- Preconditions are enforced using `Debug.assume()`
- Postconditions are verified using `assert()` statements with `.equals()` for object comparisons
- The Helper class contains stub implementations suitable for symbolic execution testing

## Troubleshooting

If you encounter issues:
1. Ensure JPF-SPBC is properly installed and configured
2. Check that the classpath in .jpf files points to the correct build directory
3. Verify that all Java files compile without errors
4. Make sure the package structure matches the directory structure

