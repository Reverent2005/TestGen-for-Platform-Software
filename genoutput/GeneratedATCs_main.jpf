# Target class
target = in.ac.iiitb.plproject.atc.generated.GeneratedATCs

# Set the classpath to point to your compiled classes
classpath = ${jpf-symbc}/build/examples

# Path to source code
sourcepath = ${jpf-symbc}/src/examples

# Define symbolic variables in the method under test
symbolic.method = in.ac.iiitb.plproject.atc.generated.GeneratedATCs.main(java.lang.String[])

# Symbolic string variables created via Debug.makeSymbolicString
symbolic.string_dp = true

# Integer ranges
symbolic.minint = -100
symbolic.maxint = 100
symbolic.undefined = -1000

# Search bounds to prevent infinite exploration
search.depth_limit = 200
search.time_limit = 60
search.multiple_errors = true
search.class = .search.heuristic.BFSHeuristic

# Listeners for test input extraction and coverage
# SymbolicSequenceListener generates JUnit tests with concrete values
listener = gov.nasa.jpf.symbc.sequences.SymbolicSequenceListener,gov.nasa.jpf.listener.CoverageAnalyzer

# Show method coverage
coverage.include = *.GeneratedATCs
coverage.show_methods = true
coverage.show_bodies = true

# To extract concrete test input values from JPF output:
# 1. Look for 'pc X constraint # = Y' sections - these show path conditions
# 2. Look for 'JUnit 4.0 test class' section - shows generated test cases
# 3. The path conditions show constraints; JPF's solver finds values satisfying them
# 4. For actual concrete values, check the constraint solver output or add Debug.printPC() calls
