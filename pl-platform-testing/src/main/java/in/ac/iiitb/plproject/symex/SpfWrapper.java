package in.ac.iiitb.plproject.symex;

import in.ac.iiitb.plproject.atc.JavaFile;
import in.ac.iiitb.plproject.atc.ConcreteInput;
import in.ac.iiitb.plproject.atc.ir.AtcClass;
import in.ac.iiitb.plproject.atc.ir.AtcTestMethod;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;

/**
 * Wrapper for Symbolic PathFinder (SPF) execution.
 * 
 * This class transforms simple Java test code to JPF-compatible code by:
 * 1. Adding JPF-specific imports (gov.nasa.jpf.symbc.Debug)
 * 2. Converting Symbolic.input() calls to Debug.makeSymbolic*() calls
 * 3. Converting assume() calls to Debug.assume()
 * 4. Adding necessary JPF infrastructure
 */
public class SpfWrapper {
    
    /**
     * Transforms simple Java code to JPF-compatible code.
     * 
     * @param simpleJavaCode The simple Java code generated by NewGenATC
     * @return JPF-compatible Java code
     */
    public String transformToJpfCode(String simpleJavaCode) {
        StringBuilder jpfCode = new StringBuilder();
        String[] lines = simpleJavaCode.split("\n");
        boolean importsAdded = false;
        
        for (String line : lines) {
            // Add JPF imports after the package declaration
            if (line.trim().startsWith("package ") && !importsAdded) {
                jpfCode.append(line).append("\n\n");
                // Add JPF imports
                jpfCode.append("import gov.nasa.jpf.symbc.Debug;\n");
                importsAdded = true;
                continue;
            }
            
            // Skip existing Debug import if present (shouldn't be in simple code, but just in case)
            if (line.trim().startsWith("import gov.nasa.jpf.symbc.Debug")) {
                continue;
            }
            
            // Transform Symbolic.input() to Debug.makeSymbolic*() based on type
            if (line.contains("Symbolic.input(")) {
                line = transformSymbolicInput(line);
            }
            
            // Transform assume() to Debug.assume()
            if (line.contains("assume(") && !line.contains("Debug.assume(")) {
                line = line.replace("assume(", "Debug.assume(");
            }
            
            jpfCode.append(line).append("\n");
        }
        
        return jpfCode.toString();
    }
    
    /**
     * Transforms Symbolic.input() calls to appropriate Debug.makeSymbolic*() calls.
     */
    private String transformSymbolicInput(String line) {
        // Pattern to match: type varName = Symbolic.input("varName");
        // or: type varName = (Type) Symbolic.input("varName");
        
        // Match: int x = Symbolic.input("x");
        Pattern pattern1 = Pattern.compile("(\\s+)(int|double|String|boolean|Integer|Double|Boolean)\\s+(\\w+)\\s*=\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher1 = pattern1.matcher(line);
        if (matcher1.find()) {
            String indent = matcher1.group(1);
            String type = matcher1.group(2);
            String varName = matcher1.group(3);
            String varNameInQuotes = matcher1.group(4);
            
            String debugCall = getDebugMakeSymbolicCall(type, varNameInQuotes);
            return indent + type + " " + varName + " = " + debugCall + ";";
        }
        
        // Match: Type varName = (Type) Symbolic.input("varName");
        Pattern pattern2 = Pattern.compile("(\\s+)(\\w+)\\s+(\\w+)\\s*=\\s*\\(([\\w.]+)\\)\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher2 = pattern2.matcher(line);
        if (matcher2.find()) {
            String indent = matcher2.group(1);
            String type = matcher2.group(2);
            String varName = matcher2.group(3);
            String castType = matcher2.group(4);
            String varNameInQuotes = matcher2.group(5);
            
            String debugCall = "(" + castType + ") Debug.makeSymbolicRef(\"" + varNameInQuotes + "\")";
            return indent + type + " " + varName + " = " + debugCall + ";";
        }
        
        // Fallback: just replace Symbolic.input with Debug.makeSymbolicRef
        return line.replace("Symbolic.input(", "Debug.makeSymbolicRef(");
    }
    
    /**
     * Gets the appropriate Debug.makeSymbolic*() call based on type.
     * Based on SPF examples from LibReturnBook.java:
     * - makeSymbolicString() for String
     * - makeSymbolicInteger() for int
     * - makeSymbolicDouble() for double
     * - makeSymbolicRef() for objects
     */
    private String getDebugMakeSymbolicCall(String type, String varName) {
        if (type.equalsIgnoreCase("int") || type.equals("Integer")) {
            // SPF examples use makeSymbolicInteger (as seen in LibReturnBook.java line 413)
            return "Debug.makeSymbolicInteger(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("double") || type.equals("Double")) {
            return "Debug.makeSymbolicDouble(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("String")) {
            return "Debug.makeSymbolicString(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("boolean") || type.equals("Boolean")) {
            // JPF doesn't have makeSymbolicBoolean, so use int and convert
            return "Debug.makeSymbolicInteger(\"" + varName + "\") != 0";
        } else {
            // For objects, use makeSymbolicRef with cast
            return "(" + type + ") Debug.makeSymbolicRef(\"" + varName + "\")";
        }
    }
    
    /**
     * Extracts package and class name from Java code.
     * 
     * @param javaCode The Java code
     * @return Array [packageName, className] or null if not found
     */
    private String[] extractClassInfo(String javaCode) {
        String packageName = null;
        String className = null;
        
        String[] lines = javaCode.split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.startsWith("package ")) {
                packageName = line.substring(8, line.length() - 1).trim();
            } else if (line.startsWith("public class ")) {
                className = line.substring(13).split("\\s|\\{")[0].trim();
                break;
            }
        }
        
        if (packageName != null && className != null) {
            return new String[]{packageName, className};
        }
        return null;
    }
    
    /**
     * Extracts test method names from Java code.
     * 
     * @param javaCode The Java code
     * @return List of test method names
     */
    private List<String> extractTestMethods(String javaCode) {
        List<String> methods = new ArrayList<>();
        Pattern methodPattern = Pattern.compile("public\\s+void\\s+(test_\\w+)\\s*\\(\\s*\\)");
        Matcher matcher = methodPattern.matcher(javaCode);
        
        while (matcher.find()) {
            methods.add(matcher.group(1));
        }
        
        return methods;
    }
    
    /**
     * Prints both the simple Java version, JPF-transformed version, and .jpf file content.
     * 
     * @param simpleJavaCode The simple Java code
     */
    public void printBothVersions(String simpleJavaCode) {
        String separator = "================================================================================";
        System.out.println(separator);
        System.out.println("SIMPLE JAVA CODE (Generated by NewGenATC):");
        System.out.println(separator);
        System.out.println(simpleJavaCode);
        System.out.println();
        
        String jpfCode = transformToJpfCode(simpleJavaCode);
        System.out.println(separator);
        System.out.println("JPF-TRANSFORMED CODE (Ready for Symbolic PathFinder):");
        System.out.println(separator);
        System.out.println(jpfCode);
        System.out.println();
        
        // Extract class info and generate .jpf file content
        String[] classInfo = extractClassInfo(simpleJavaCode);
        if (classInfo != null) {
            String packageName = classInfo[0];
            String className = classInfo[1];
            String fullClassName = packageName + "." + className;
            
            List<String> testMethods = extractTestMethods(simpleJavaCode);
            
            if (!testMethods.isEmpty()) {
                System.out.println(separator);
                System.out.println("GENERATED .JPF CONFIGURATION FILES:");
                System.out.println(separator);
                
                // Generate .jpf file for the first test method as example
                String firstMethod = testMethods.get(0);
                try {
                    String jpfContent = generateJpfFile(fullClassName, firstMethod, null, null, null);
                    System.out.println("# Example .jpf file for: " + fullClassName + "." + firstMethod + "()");
                    System.out.println(jpfContent);
                    System.out.println();
                    
                    if (testMethods.size() > 1) {
                        System.out.println("# Note: " + (testMethods.size() - 1) + " more test method(s) found.");
                        System.out.println("# Use generateJpfFilesForMethods() to generate .jpf files for all methods.");
                    }
                } catch (IOException e) {
                    System.err.println("Error generating .jpf file: " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Runs symbolic execution on the generated ATC file.
     * 
     * @param atcJavaFile The generated test file (simple Java code)
     * @return List of concrete test inputs found by SPF
     */
    public List<ConcreteInput> run(JavaFile atcJavaFile) {
        // Print both versions
        printBothVersions(atcJavaFile.getContent());
        
        // Transform to JPF code (stored for future SPF invocation)
        String jpfCode = transformToJpfCode(atcJavaFile.getContent());
        
        // TODO: Implement actual SPF invocation
        // 1. Write jpfCode to disk
        // 2. Invoke SPF/JPF on that file
        // 3. Parse the results and return ConcreteInput objects
        
        System.out.println("(SPF execution not yet implemented)");
        
        // Return empty list for now
        return new ArrayList<ConcreteInput>();
    }
    
    /**
     * Gets the JPF-transformed code without printing.
     * 
     * @param simpleJavaCode The simple Java code
     * @return JPF-transformed code
     */
    public String getJpfCode(String simpleJavaCode) {
        return transformToJpfCode(simpleJavaCode);
    }
    
    /**
     * Generates a .jpf configuration file for JPF execution.
     * Based on the SPF example structure.
     * 
     * @param className Fully qualified class name (e.g., "in.ac.iiitb.plproject.atc.generated.GeneratedATCs")
     * @param methodName Method name to test (e.g., "test_increment_0")
     * @param outputPath Path where to save the .jpf file (e.g., "GeneratedATCs.jpf")
     * @param classpath JPF classpath (defaults to ${jpf-symbc}/build/examples if null)
     * @param sourcepath JPF sourcepath (defaults to ${jpf-symbc}/src/examples if null)
     * @return The generated .jpf file content as a string
     * @throws IOException If file writing fails
     */
    public String generateJpfFile(String className, String methodName, String outputPath, 
                                   String classpath, String sourcepath) throws IOException {
        StringBuilder jpfContent = new StringBuilder();
        
        // Target class
        jpfContent.append("# Target class\n");
        jpfContent.append("target = ").append(className).append("\n\n");
        
        // Classpath
        jpfContent.append("# Set the classpath to point to your compiled classes\n");
        if (classpath != null && !classpath.isEmpty()) {
            jpfContent.append("classpath = ").append(classpath).append("\n");
        } else {
            jpfContent.append("classpath = ${jpf-symbc}/build/examples\n");
        }
        jpfContent.append("\n");
        
        // Sourcepath
        jpfContent.append("# Path to source code\n");
        if (sourcepath != null && !sourcepath.isEmpty()) {
            jpfContent.append("sourcepath = ").append(sourcepath).append("\n");
        } else {
            jpfContent.append("sourcepath = ${jpf-symbc}/src/examples\n");
        }
        jpfContent.append("\n");
        
        // Symbolic method
        jpfContent.append("# Define symbolic variables in the method under test\n");
        jpfContent.append("symbolic.method = ").append(className).append(".").append(methodName).append("()\n\n");
        
        // Symbolic string decision procedures
        jpfContent.append("# Symbolic string variables created via Debug.makeSymbolicString\n");
        jpfContent.append("symbolic.string_dp = true\n\n");
        
        // Integer ranges
        jpfContent.append("# Integer ranges\n");
        jpfContent.append("symbolic.minint = -100\n");
        jpfContent.append("symbolic.maxint = 100\n");
        jpfContent.append("symbolic.undefined = -1000\n\n");
        
        // Coverage listener
        jpfContent.append("# Coverage listener (optional but useful for insights)\n");
        jpfContent.append("listener = gov.nasa.jpf.symbc.sequences.SymbolicSequenceListener,gov.nasa.jpf.listener.CoverageAnalyzer\n\n");
        
        // Coverage settings
        String simpleClassName = className.substring(className.lastIndexOf('.') + 1);
        jpfContent.append("# Show method coverage\n");
        jpfContent.append("coverage.include = *.").append(simpleClassName).append("\n");
        jpfContent.append("coverage.show_methods = true\n");
        jpfContent.append("coverage.show_bodies = true\n");
        
        String content = jpfContent.toString();
        
        // Write to file if outputPath is provided
        if (outputPath != null && !outputPath.isEmpty()) {
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(content);
            }
        }
        
        return content;
    }
    
    /**
     * Generates a .jpf file for each test method in the generated class.
     * 
     * @param className Fully qualified class name
     * @param methodNames List of method names to generate .jpf files for
     * @param outputDir Directory where to save .jpf files (null = current directory)
     * @param classpath JPF classpath
     * @param sourcepath JPF sourcepath
     * @return List of generated .jpf file paths
     * @throws IOException If file writing fails
     */
    public List<String> generateJpfFilesForMethods(String className, List<String> methodNames, 
                                                    String outputDir, String classpath, String sourcepath) 
            throws IOException {
        List<String> generatedFiles = new ArrayList<>();
        String simpleClassName = className.substring(className.lastIndexOf('.') + 1);
        
        for (String methodName : methodNames) {
            String jpfFileName = simpleClassName + "_" + methodName + ".jpf";
            String outputPath = (outputDir != null && !outputDir.isEmpty()) 
                ? Paths.get(outputDir, jpfFileName).toString() 
                : jpfFileName;
            
            generateJpfFile(className, methodName, outputPath, classpath, sourcepath);
            generatedFiles.add(outputPath);
        }
        
        return generatedFiles;
    }
    
    /**
     * Generates .jpf files for all test methods in an AtcClass.
     * This is a convenience method that extracts class info from AtcClass.
     * 
     * @param atcClass The AtcClass IR object
     * @param outputDir Directory where to save .jpf files (null = current directory)
     * @param classpath JPF classpath (null = use default)
     * @param sourcepath JPF sourcepath (null = use default)
     * @return List of generated .jpf file paths
     * @throws IOException If file writing fails
     */
    public List<String> generateJpfFilesFromAtcClass(AtcClass atcClass, String outputDir, 
                                                     String classpath, String sourcepath) 
            throws IOException {
        String fullClassName = atcClass.getPackageName() + "." + atcClass.getClassName();
        List<String> methodNames = new ArrayList<>();
        
        for (AtcTestMethod method : atcClass.getTestMethods()) {
            methodNames.add(method.getMethodName());
        }
        
        return generateJpfFilesForMethods(fullClassName, methodNames, outputDir, classpath, sourcepath);
    }
}
