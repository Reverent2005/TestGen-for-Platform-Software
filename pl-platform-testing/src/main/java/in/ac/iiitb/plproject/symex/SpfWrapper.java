package in.ac.iiitb.plproject.symex;

import in.ac.iiitb.plproject.atc.JavaFile;
import in.ac.iiitb.plproject.atc.ConcreteInput;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Wrapper for Symbolic PathFinder (SPF) execution.
 * 
 * This class transforms simple Java test code to JPF-compatible code by:
 * 1. Adding JPF-specific imports (gov.nasa.jpf.symbc.Debug)
 * 2. Converting Symbolic.input() calls to Debug.makeSymbolic*() calls
 * 3. Converting assume() calls to Debug.assume()
 * 4. Adding necessary JPF infrastructure
 */
public class SpfWrapper {
    
    /**
     * Transforms simple Java code to JPF-compatible code.
     * 
     * @param simpleJavaCode The simple Java code generated by NewGenATC
     * @return JPF-compatible Java code
     */
    public String transformToJpfCode(String simpleJavaCode) {
        StringBuilder jpfCode = new StringBuilder();
        String[] lines = simpleJavaCode.split("\n");
        boolean importsAdded = false;
        
        for (String line : lines) {
            // Add JPF imports after the package declaration
            if (line.trim().startsWith("package ") && !importsAdded) {
                jpfCode.append(line).append("\n\n");
                // Add JPF imports
                jpfCode.append("import gov.nasa.jpf.symbc.Debug;\n");
                importsAdded = true;
                continue;
            }
            
            // Skip existing Debug import if present (shouldn't be in simple code, but just in case)
            if (line.trim().startsWith("import gov.nasa.jpf.symbc.Debug")) {
                continue;
            }
            
            // Transform Symbolic.input() to Debug.makeSymbolic*() based on type
            if (line.contains("Symbolic.input(")) {
                line = transformSymbolicInput(line);
            }
            
            // Transform assume() to Debug.assume()
            if (line.contains("assume(") && !line.contains("Debug.assume(")) {
                line = line.replace("assume(", "Debug.assume(");
            }
            
            jpfCode.append(line).append("\n");
        }
        
        return jpfCode.toString();
    }
    
    /**
     * Transforms Symbolic.input() calls to appropriate Debug.makeSymbolic*() calls.
     */
    private String transformSymbolicInput(String line) {
        // Pattern to match: type varName = Symbolic.input("varName");
        // or: type varName = (Type) Symbolic.input("varName");
        
        // Match: int x = Symbolic.input("x");
        Pattern pattern1 = Pattern.compile("(\\s+)(int|double|String|boolean|Integer|Double|Boolean)\\s+(\\w+)\\s*=\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher1 = pattern1.matcher(line);
        if (matcher1.find()) {
            String indent = matcher1.group(1);
            String type = matcher1.group(2);
            String varName = matcher1.group(3);
            String varNameInQuotes = matcher1.group(4);
            
            String debugCall = getDebugMakeSymbolicCall(type, varNameInQuotes);
            return indent + type + " " + varName + " = " + debugCall + ";";
        }
        
        // Match: Type varName = (Type) Symbolic.input("varName");
        Pattern pattern2 = Pattern.compile("(\\s+)(\\w+)\\s+(\\w+)\\s*=\\s*\\(([\\w.]+)\\)\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher2 = pattern2.matcher(line);
        if (matcher2.find()) {
            String indent = matcher2.group(1);
            String type = matcher2.group(2);
            String varName = matcher2.group(3);
            String castType = matcher2.group(4);
            String varNameInQuotes = matcher2.group(5);
            
            String debugCall = "(" + castType + ") Debug.makeSymbolicRef(\"" + varNameInQuotes + "\")";
            return indent + type + " " + varName + " = " + debugCall + ";";
        }
        
        // Fallback: just replace Symbolic.input with Debug.makeSymbolicRef
        return line.replace("Symbolic.input(", "Debug.makeSymbolicRef(");
    }
    
    /**
     * Gets the appropriate Debug.makeSymbolic*() call based on type.
     */
    private String getDebugMakeSymbolicCall(String type, String varName) {
        if (type.equalsIgnoreCase("int") || type.equals("Integer")) {
            return "Debug.makeSymbolicInt(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("double") || type.equals("Double")) {
            return "Debug.makeSymbolicDouble(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("String")) {
            return "Debug.makeSymbolicString(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("boolean") || type.equals("Boolean")) {
            // JPF doesn't have makeSymbolicBoolean, so use int and convert
            return "Debug.makeSymbolicInt(\"" + varName + "\") != 0";
        } else {
            // For objects, use makeSymbolicRef with cast
            return "(" + type + ") Debug.makeSymbolicRef(\"" + varName + "\")";
        }
    }
    
    /**
     * Prints both the simple Java version and the JPF-transformed version.
     * 
     * @param simpleJavaCode The simple Java code
     */
    public void printBothVersions(String simpleJavaCode) {
        String separator = "================================================================================";
        System.out.println(separator);
        System.out.println("SIMPLE JAVA CODE (Generated by NewGenATC):");
        System.out.println(separator);
        System.out.println(simpleJavaCode);
        System.out.println();
        
        String jpfCode = transformToJpfCode(simpleJavaCode);
        System.out.println(separator);
        System.out.println("JPF-TRANSFORMED CODE (Ready for Symbolic PathFinder):");
        System.out.println(separator);
        System.out.println(jpfCode);
        System.out.println();
    }
    
    /**
     * Runs symbolic execution on the generated ATC file.
     * 
     * @param atcJavaFile The generated test file (simple Java code)
     * @return List of concrete test inputs found by SPF
     */
    public List<ConcreteInput> run(JavaFile atcJavaFile) {
        // Print both versions
        printBothVersions(atcJavaFile.getContent());
        
        // Transform to JPF code (stored for future SPF invocation)
        String jpfCode = transformToJpfCode(atcJavaFile.getContent());
        
        // TODO: Implement actual SPF invocation
        // 1. Write jpfCode to disk
        // 2. Invoke SPF/JPF on that file
        // 3. Parse the results and return ConcreteInput objects
        
        System.out.println("(SPF execution not yet implemented)");
        
        // Return empty list for now
        return new ArrayList<ConcreteInput>();
    }
    
    /**
     * Gets the JPF-transformed code without printing.
     * 
     * @param simpleJavaCode The simple Java code
     * @return JPF-transformed code
     */
    public String getJpfCode(String simpleJavaCode) {
        return transformToJpfCode(simpleJavaCode);
    }
}
