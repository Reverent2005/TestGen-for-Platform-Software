package in.ac.iiitb.plproject.symex;

import in.ac.iiitb.plproject.atc.JavaFile;
import in.ac.iiitb.plproject.atc.ConcreteInput;
import in.ac.iiitb.plproject.atc.ir.AtcClass;
import in.ac.iiitb.plproject.atc.ir.AtcTestMethod;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;

/**
 * Wrapper for Symbolic PathFinder (SPF) execution.
 * 
 * This class transforms simple Java test code to JPF-compatible code by:
 * 1. Adding JPF-specific imports (gov.nasa.jpf.symbc.Debug)
 * 2. Converting Symbolic.input() calls to Debug.makeSymbolic*() calls
 * 3. Converting assume() calls to Debug.assume()
 * 4. Adding necessary JPF infrastructure
 */
public class SpfWrapper {
    
    /**
     * Transforms simple Java code to JPF-compatible code.
     * 
     * @param simpleJavaCode The simple Java code generated by NewGenATC
     * @return JPF-compatible Java code
     */
    public String transformToJpfCode(String simpleJavaCode) {
        StringBuilder jpfCode = new StringBuilder();
        String[] lines = simpleJavaCode.split("\n");
        boolean importsAdded = false;
        
        for (String line : lines) {
            // Add JPF imports after the package declaration
            if (line.trim().startsWith("package ") && !importsAdded) {
                jpfCode.append(line).append("\n\n");
                // Add JPF imports
                jpfCode.append("import gov.nasa.jpf.symbc.Debug;\n");
                importsAdded = true;
                continue;
            }
            
            // Skip existing Debug import if present (shouldn't be in simple code, but just in case)
            if (line.trim().startsWith("import gov.nasa.jpf.symbc.Debug")) {
                continue;
            }
            
            // Transform Symbolic.input() to Debug.makeSymbolic*() based on type
            if (line.contains("Symbolic.input(")) {
                line = transformSymbolicInput(line);
            }
            
            // Transform assume() to Debug.assume()
            if (line.contains("assume(") && !line.contains("Debug.assume(")) {
                line = line.replace("assume(", "Debug.assume(");
            }
            
            jpfCode.append(line).append("\n");
        }
        
        return jpfCode.toString();
    }
    
    /**
     * Transforms Symbolic.input() calls to appropriate Debug.makeSymbolic*() calls.
     */
    private String transformSymbolicInput(String line) {
        // Pattern to match: type varName = Symbolic.input("varName");
        // or: type varName = (Type) Symbolic.input("varName");
        
        // Match: int x = Symbolic.input("x");
        Pattern pattern1 = Pattern.compile("(\\s+)(int|double|String|boolean|Integer|Double|Boolean)\\s+(\\w+)\\s*=\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher1 = pattern1.matcher(line);
        if (matcher1.find()) {
            String indent = matcher1.group(1);
            String type = matcher1.group(2);
            String varName = matcher1.group(3);
            String varNameInQuotes = matcher1.group(4);
            
            String debugCall = getDebugMakeSymbolicCall(type, varNameInQuotes);
            return indent + type + " " + varName + " = " + debugCall + ";";
        }
        
        // Match: Type varName = (Type) Symbolic.input("varName");
        // Handle generic types like Set<?>, Map<?,?> etc.
        Pattern pattern2 = Pattern.compile("(\\s+)([\\w.<?>,]+)\\s+(\\w+)\\s*=\\s*\\(([\\w.<?>,]+)\\)\\s*Symbolic\\.input\\(\"([^\"]+)\"\\);");
        Matcher matcher2 = pattern2.matcher(line);
        if (matcher2.find()) {
            String indent = matcher2.group(1);
            String type = matcher2.group(2);
            String varName = matcher2.group(3);
            String castType = matcher2.group(4);
            String varNameInQuotes = matcher2.group(5);
            
            // Extract base type from generic type (e.g., "Set<?>" -> "Set")
            String baseType = castType.split("[<>]")[0].trim();
            
            // Check if it's a collection type - if so, use symbolic initialization
            if (TypeMapper.isCollectionType(baseType)) {
                String genericType = TypeMapper.getGenericType(baseType);
                String initCode = TypeMapper.getCollectionInitCode(baseType, varNameInQuotes);
                return indent + genericType + " " + varName + " = " + initCode + ";";
            } else {
                // For custom classes, use makeSymbolicRef with null
                // Collections are handled above, so this is safe for custom classes
                String debugCall = TypeMapper.getMakeSymbolicRefCall(baseType, varNameInQuotes, false);
                return indent + type + " " + varName + " = " + debugCall + ";";
            }
        }
        
        // Fallback: check if it's a collection type before using makeSymbolicRef
        if (line.contains("Symbolic.input(")) {
            // Try to extract type and check if it's a collection
            Pattern fallbackPattern = Pattern.compile("(\\s+)([\\w.<?>,]+)\\s+(\\w+)\\s*=\\s*.*Symbolic\\.input\\(\"([^\"]+)\"\\);");
            Matcher fallbackMatcher = fallbackPattern.matcher(line);
            if (fallbackMatcher.find()) {
                String type = fallbackMatcher.group(2);
                String baseType = type.split("[<>]")[0].trim();
                if (TypeMapper.isCollectionType(baseType)) {
                    String genericType = TypeMapper.getGenericType(baseType);
                    String varName = fallbackMatcher.group(3);
                    String varNameInQuotes = fallbackMatcher.group(4);
                    String initCode = TypeMapper.getCollectionInitCode(baseType, varNameInQuotes);
                    return fallbackMatcher.group(1) + genericType + " " + varName + " = " + initCode + ";";
                }
            }
            // For non-collections, use makeSymbolicRef but try to avoid null
            return line.replace("Symbolic.input(\"", "Debug.makeSymbolicRef(\"").replace("\")", "\", null)");
        }
        
        return line;
    }
    
    /**
     * Gets the appropriate Debug.makeSymbolic*() call based on type.
     * Based on SPF examples from LibReturnBook.java:
     * - makeSymbolicString() for String
     * - makeSymbolicInteger() for int
     * - makeSymbolicDouble() for double
     * - makeSymbolicRef() for objects (requires Object parameter)
     * Uses TypeMapper to intelligently handle collections and custom classes.
     */
    private String getDebugMakeSymbolicCall(String type, String varName) {
        if (type.equalsIgnoreCase("int") || type.equals("Integer")) {
            // SPF examples use makeSymbolicInteger
            return "Debug.makeSymbolicInteger(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("double") || type.equals("Double")) {
            return "Debug.makeSymbolicDouble(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("String")) {
            return "Debug.makeSymbolicString(\"" + varName + "\")";
        } else if (type.equalsIgnoreCase("boolean") || type.equals("Boolean")) {
            // JPF doesn't have makeSymbolicBoolean, so use int and convert
            return "Debug.makeSymbolicInteger(\"" + varName + "\") != 0";
        } else if (TypeMapper.isCollectionType(type)) {
            // Collections should use symbolic initialization with empty collection as default
            // This shouldn't normally be called for collections, but handle it gracefully
            return TypeMapper.getCollectionInitCode(type, varName);
        } else {
            // For custom classes, use makeSymbolicRef with null
            // Collections are handled above, so this is safe for custom classes
            return TypeMapper.getMakeSymbolicRefCall(type, varName, false);
        }
    }
    
    /**
     * Extracts package and class name from Java code.
     * 
     * @param javaCode The Java code
     * @return Array [packageName, className] or null if not found
     */
    private String[] extractClassInfo(String javaCode) {
        String packageName = null;
        String className = null;
        
        String[] lines = javaCode.split("\n");
        for (String line : lines) {
            line = line.trim();
            if (line.startsWith("package ")) {
                packageName = line.substring(8, line.length() - 1).trim();
            } else if (line.startsWith("public class ")) {
                className = line.substring(13).split("\\s|\\{")[0].trim();
                break;
            }
        }
        
        if (packageName != null && className != null) {
            return new String[]{packageName, className};
        }
        return null;
    }
    
    /**
     * Extracts test method names from Java code.
     * 
     * @param javaCode The Java code
     * @return List of test method names
     */
    private List<String> extractTestMethods(String javaCode) {
        List<String> methods = new ArrayList<>();
        Pattern methodPattern = Pattern.compile("public\\s+void\\s+(test_\\w+)\\s*\\(\\s*\\)");
        Matcher matcher = methodPattern.matcher(javaCode);
        
        while (matcher.find()) {
            methods.add(matcher.group(1));
        }
        
        return methods;
    }
    
    /**
     * Extracts the method signature (including parameters) from Java code.
     * Returns the signature in JPF format: methodName(paramType1,paramType2,...)
     * JPF uses Java-style type names, e.g., main(java.lang.String[])
     * 
     * @param javaCode The Java code
     * @param methodName The method name to find
     * @return Method signature in JPF format, or methodName() if not found or no parameters
     */
    private String extractMethodSignature(String javaCode, String methodName) {
        // Pattern to match method declarations with parameters
        // Handles: public static void main(String[] args) or public void methodName() etc.
        // More flexible pattern to handle various method declarations
        Pattern methodPattern = Pattern.compile(
            "(?:public|private|protected)?\\s*(?:static)?\\s*(?:void|\\w+)\\s+" + 
            Pattern.quote(methodName) + 
            "\\s*\\(([^)]*)\\)"
        );
        Matcher matcher = methodPattern.matcher(javaCode);
        
        if (matcher.find()) {
            String params = matcher.group(1).trim();
            if (params.isEmpty()) {
                return methodName + "()";
            }
            
            // Parse parameters and convert to JPF format
            // Split by comma, but be careful with generics
            List<String> paramParts = new ArrayList<>();
            int depth = 0;
            StringBuilder currentParam = new StringBuilder();
            
            for (char c : params.toCharArray()) {
                if (c == '<') depth++;
                else if (c == '>') depth--;
                else if (c == ',' && depth == 0) {
                    paramParts.add(currentParam.toString().trim());
                    currentParam = new StringBuilder();
                    continue;
                }
                currentParam.append(c);
            }
            if (currentParam.length() > 0) {
                paramParts.add(currentParam.toString().trim());
            }
            
            StringBuilder signature = new StringBuilder(methodName + "(");
            
            for (int i = 0; i < paramParts.size(); i++) {
                String param = paramParts.get(i);
                if (param.isEmpty()) continue;
                
                // Extract type (handle arrays and generics)
                // Remove parameter name, annotations, final keyword
                param = param.replaceAll("^@\\w+\\s*", ""); // Remove annotations
                param = param.replaceAll("^final\\s+", ""); // Remove final
                // Remove parameter name - match word at end that's not part of type
                param = param.replaceAll("\\s+[a-zA-Z_][a-zA-Z0-9_]*$", "");
                param = param.trim();
                
                // Convert to fully qualified type names for JPF (Java-style, not JVM descriptor)
                if (param.equals("String[]") || param.equals("String []")) {
                    signature.append("java.lang.String[]");
                } else if (param.equals("int[]") || param.equals("int []")) {
                    signature.append("int[]");
                } else if (param.equals("double[]") || param.equals("double []")) {
                    signature.append("double[]");
                } else if (param.equals("boolean[]") || param.equals("boolean []")) {
                    signature.append("boolean[]");
                } else if (param.equals("String")) {
                    signature.append("java.lang.String");
                } else if (param.equals("int")) {
                    signature.append("int");
                } else if (param.equals("double")) {
                    signature.append("double");
                } else if (param.equals("boolean")) {
                    signature.append("boolean");
                } else if (param.equals("long")) {
                    signature.append("long");
                } else if (param.equals("float")) {
                    signature.append("float");
                } else if (param.equals("char")) {
                    signature.append("char");
                } else if (param.equals("byte")) {
                    signature.append("byte");
                } else if (param.equals("short")) {
                    signature.append("short");
                } else if (param.contains("[]")) {
                    // Array type - keep Java-style format
                    signature.append(param);
                } else {
                    // For other types, use as-is (assume fully qualified or will be resolved)
                    signature.append(param);
                }
                
                if (i < paramParts.size() - 1) {
                    signature.append(",");
                }
            }
            
            signature.append(")");
            return signature.toString();
        }
        
        // Fallback: return method name with empty parentheses
        return methodName + "()";
    }
    
    /**
     * Prints both the simple Java version, JPF-transformed version, and .jpf file content.
     * 
     * @param simpleJavaCode The simple Java code
     */
    public void printBothVersions(String simpleJavaCode) {
        String separator = "================================================================================";
        System.out.println(separator);
        System.out.println("SIMPLE JAVA CODE (Generated by NewGenATC):");
        System.out.println(separator);
        System.out.println(simpleJavaCode);
        System.out.println();
        
        String jpfCode = transformToJpfCode(simpleJavaCode);
        System.out.println(separator);
        System.out.println("JPF-TRANSFORMED CODE (Ready for Symbolic PathFinder):");
        System.out.println(separator);
        System.out.println(jpfCode);
        System.out.println();
        
        // Extract class info and generate .jpf file content
        String[] classInfo = extractClassInfo(simpleJavaCode);
        if (classInfo != null) {
            String packageName = classInfo[0];
            String className = classInfo[1];
            String fullClassName = packageName + "." + className;
            
            List<String> testMethods = extractTestMethods(simpleJavaCode);
            
            if (!testMethods.isEmpty()) {
                System.out.println(separator);
                System.out.println("GENERATED .JPF CONFIGURATION FILES:");
                System.out.println(separator);
                
                // Generate .jpf file for the first test method as example
                String firstMethod = testMethods.get(0);
                try {
                    String jpfContent = generateJpfFile(fullClassName, firstMethod, null, null, null, simpleJavaCode);
                    System.out.println("# Example .jpf file for: " + fullClassName + "." + firstMethod + "()");
                    System.out.println(jpfContent);
                    System.out.println();
                    
                    if (testMethods.size() > 1) {
                        System.out.println("# Note: " + (testMethods.size() - 1) + " more test method(s) found.");
                        System.out.println("# Use generateJpfFilesForMethods() to generate .jpf files for all methods.");
                    }
                } catch (IOException e) {
                    System.err.println("Error generating .jpf file: " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Runs symbolic execution on the generated ATC file.
     * 
     * @param atcJavaFile The generated test file (simple Java code)
     * @return List of concrete test inputs found by SPF
     */
    public List<ConcreteInput> run(JavaFile atcJavaFile) {
        // Legacy method - call the new overloaded version with null AtcClass
        return run(atcJavaFile, null);
    }
    
    /**
     * Runs symbolic execution on the generated ATC file and saves output files.
     * 
     * @param atcJavaFile The generated test file (simple Java code)
     * @param atcClass The AtcClass IR object (optional, used for file generation)
     * @return List of concrete test inputs found by SPF
     */
    public List<ConcreteInput> run(JavaFile atcJavaFile, AtcClass atcClass) {
        // Print both versions
        printBothVersions(atcJavaFile.getContent());
        
        // Transform to JPF code (stored for future SPF invocation)
        String jpfCode = transformToJpfCode(atcJavaFile.getContent());
        
        // Save the JPF-transformed Java file and generate .jpf files
        try {
            saveOutputFiles(atcJavaFile.getContent(), jpfCode, atcClass);
        } catch (IOException e) {
            System.err.println("Error saving output files: " + e.getMessage());
            e.printStackTrace();
        }
        
        // TODO: Implement actual SPF invocation
        // 1. Write jpfCode to disk
        // 2. Invoke SPF/JPF on that file
        // 3. Parse the results and return ConcreteInput objects
        
        System.out.println("(SPF execution not yet implemented)");
        
        // Return empty list for now
        return new ArrayList<ConcreteInput>();
    }
    
    /**
     * Saves the JPF-transformed Java file and generates .jpf files in the outputs directory.
     * 
     * @param simpleJavaCode The original simple Java code
     * @param jpfCode The JPF-transformed Java code
     * @param atcClass The AtcClass IR object (optional, if null extracts from code)
     */
    private void saveOutputFiles(String simpleJavaCode, String jpfCode, AtcClass atcClass) throws IOException {
        System.out.println("\n=== Saving output files ===");
        // Determine output directory
        String outputDir = "outputs";
        java.io.File outputDirFile = new java.io.File(outputDir);
        if (!outputDirFile.exists()) {
            boolean created = outputDirFile.mkdirs();
            System.out.println("Created outputs directory: " + created + " (path: " + outputDirFile.getAbsolutePath() + ")");
        } else {
            System.out.println("Outputs directory already exists: " + outputDirFile.getAbsolutePath());
        }
        
        // Extract class information
        String packageName = null;
        String className = null;
        String fullClassName = null;
        List<String> testMethods = new ArrayList<>();
        
        if (atcClass != null) {
            // Use AtcClass if provided
            packageName = atcClass.getPackageName();
            className = atcClass.getClassName();
            fullClassName = (packageName != null && !packageName.isEmpty()) 
                ? packageName + "." + className 
                : className;
            
            // Extract test method names from AtcClass
            for (AtcTestMethod method : atcClass.getTestMethods()) {
                if (method.isTestAnnotated() && !method.isMain()) {
                    testMethods.add(method.getMethodName());
                }
            }
        } else {
            // Fallback: extract from Java code
            String[] classInfo = extractClassInfo(simpleJavaCode);
            if (classInfo != null) {
                packageName = classInfo[0];
                className = classInfo[1];
                fullClassName = packageName + "." + className;
                testMethods = extractTestMethods(simpleJavaCode);
            } else {
                // Default values if extraction fails
                className = "GeneratedATCs";
                fullClassName = className;
                testMethods = extractTestMethods(simpleJavaCode);
            }
        }
        
        // Save the JPF-transformed Java file
        String javaFileName = className + ".java";
        String javaFilePath = Paths.get(outputDir, javaFileName).toString();
        try (FileWriter writer = new FileWriter(javaFilePath)) {
            writer.write(jpfCode);
            System.out.println("Saved JPF-transformed Java file: " + javaFilePath);
        }
        
        // Generate JPF file for main() method - this is the primary test that runs the full sequence
        // The main method contains the actual test sequence from the test string
        String mainJpfFileName = className + "_main.jpf";
        String mainJpfFilePath = Paths.get(outputDir, mainJpfFileName).toString();
        try {
            generateJpfFile(fullClassName, "main", mainJpfFilePath, null, null, jpfCode);
            System.out.println("Generated main .jpf file: " + mainJpfFilePath);
        } catch (IOException e) {
            System.err.println("Error generating main .jpf file: " + e.getMessage());
        }
        
        // Optionally generate .jpf files for individual test methods (for debugging)
        // But main() is the primary test that should be run
        if (!testMethods.isEmpty() && fullClassName != null) {
            List<String> jpfFiles = generateJpfFilesForMethods(fullClassName, testMethods, outputDir, null, null, jpfCode);
            System.out.println("Generated " + jpfFiles.size() + " additional .jpf file(s) for individual test methods:");
            for (String jpfFile : jpfFiles) {
                System.out.println("  - " + jpfFile);
            }
            System.out.println("Note: Use " + mainJpfFileName + " to test the complete sequence from the test string.");
        }
    }
    
    /**
     * Gets the JPF-transformed code without printing.
     * 
     * @param simpleJavaCode The simple Java code
     * @return JPF-transformed code
     */
    public String getJpfCode(String simpleJavaCode) {
        return transformToJpfCode(simpleJavaCode);
    }
    
    /**
     * Generates a .jpf configuration file for JPF execution (backward-compatible version).
     * Uses methodName() as the signature (assumes no parameters).
     * 
     * @param className Fully qualified class name
     * @param methodName Method name to test
     * @param outputPath Path where to save the .jpf file
     * @param classpath JPF classpath (defaults to ${jpf-symbc}/build/examples if null)
     * @param sourcepath JPF sourcepath (defaults to ${jpf-symbc}/src/examples if null)
     * @return The generated .jpf file content as a string
     * @throws IOException If file writing fails
     */
    public String generateJpfFile(String className, String methodName, String outputPath, 
                                   String classpath, String sourcepath) throws IOException {
        return generateJpfFile(className, methodName, outputPath, classpath, sourcepath, null);
    }
    
    /**
     * Generates a .jpf configuration file for JPF execution.
     * Based on the SPF example structure.
     * 
     * @param className Fully qualified class name (e.g., "in.ac.iiitb.plproject.atc.generated.GeneratedATCs")
     * @param methodName Method name to test (e.g., "test_increment_0" or "main")
     * @param outputPath Path where to save the .jpf file (e.g., "GeneratedATCs.jpf")
     * @param classpath JPF classpath (defaults to ${jpf-symbc}/build/examples if null)
     * @param sourcepath JPF sourcepath (defaults to ${jpf-symbc}/src/examples if null)
     * @param javaCode Optional Java code to extract method signature from. If null, uses methodName() as fallback.
     * @return The generated .jpf file content as a string
     * @throws IOException If file writing fails
     */
    public String generateJpfFile(String className, String methodName, String outputPath, 
                                   String classpath, String sourcepath, String javaCode) throws IOException {
        StringBuilder jpfContent = new StringBuilder();
        
        // Target class
        jpfContent.append("# Target class\n");
        jpfContent.append("target = ").append(className).append("\n\n");
        
        // Classpath
        jpfContent.append("# Set the classpath to point to your compiled classes\n");
        if (classpath != null && !classpath.isEmpty()) {
            jpfContent.append("classpath = ").append(classpath).append("\n");
        } else {
            jpfContent.append("classpath = ${jpf-symbc}/build/examples\n");
        }
        jpfContent.append("\n");
        
        // Sourcepath
        jpfContent.append("# Path to source code\n");
        if (sourcepath != null && !sourcepath.isEmpty()) {
            jpfContent.append("sourcepath = ").append(sourcepath).append("\n");
        } else {
            jpfContent.append("sourcepath = ${jpf-symbc}/src/examples\n");
        }
        jpfContent.append("\n");
        
        // Symbolic method - extract signature from Java code if available
        String methodSignature;
        if (javaCode != null && !javaCode.isEmpty()) {
            methodSignature = extractMethodSignature(javaCode, methodName);
        } else {
            // Fallback: assume no parameters
            methodSignature = methodName + "()";
        }
        
        jpfContent.append("# Define symbolic variables in the method under test\n");
        jpfContent.append("symbolic.method = ").append(className).append(".").append(methodSignature).append("\n\n");
        
        // Symbolic string decision procedures
        jpfContent.append("# Symbolic string variables created via Debug.makeSymbolicString\n");
        jpfContent.append("symbolic.string_dp = true\n\n");
        
        // Integer ranges
        jpfContent.append("# Integer ranges\n");
        jpfContent.append("symbolic.minint = -100\n");
        jpfContent.append("symbolic.maxint = 100\n");
        jpfContent.append("symbolic.undefined = -1000\n\n");
        
        // Search bounds to prevent infinite exploration and path explosion
        jpfContent.append("# Search bounds to prevent infinite exploration\n");
        // More restrictive bounds for main() method which calls multiple test methods
        if ("main".equals(methodName)) {
            jpfContent.append("search.depth_limit = 200\n");
            jpfContent.append("search.time_limit = 60\n"); // 1 minute timeout for main
        } else {
            jpfContent.append("search.depth_limit = 500\n");
            jpfContent.append("search.time_limit = 120\n"); // 2 minutes timeout for individual methods
        }
        jpfContent.append("search.multiple_errors = true\n");
        jpfContent.append("search.class = .search.heuristic.BFSHeuristic\n\n");
        
        // Listeners for test input extraction and coverage
        jpfContent.append("# Listeners for test input extraction and coverage\n");
        jpfContent.append("# SymbolicSequenceListener generates JUnit tests with concrete values\n");
        jpfContent.append("listener = gov.nasa.jpf.symbc.sequences.SymbolicSequenceListener,gov.nasa.jpf.listener.CoverageAnalyzer\n\n");
        
        // Coverage settings
        String simpleClassName = className.substring(className.lastIndexOf('.') + 1);
        jpfContent.append("# Show method coverage\n");
        jpfContent.append("coverage.include = *.").append(simpleClassName).append("\n");
        jpfContent.append("coverage.show_methods = true\n");
        jpfContent.append("coverage.show_bodies = true\n\n");
        
        // Instructions for extracting concrete test inputs
        jpfContent.append("# To extract concrete test input values from JPF output:\n");
        jpfContent.append("# 1. Look for 'pc X constraint # = Y' sections - these show path conditions\n");
        jpfContent.append("# 2. Look for 'JUnit 4.0 test class' section - shows generated test cases\n");
        jpfContent.append("# 3. The path conditions show constraints; JPF's solver finds values satisfying them\n");
        jpfContent.append("# 4. For actual concrete values, check the constraint solver output or add Debug.printPC() calls\n");
        
        String content = jpfContent.toString();
        
        // Write to file if outputPath is provided
        if (outputPath != null && !outputPath.isEmpty()) {
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(content);
            }
        }
        
        return content;
    }
    
    /**
     * Generates a .jpf file for each test method in the generated class.
     * 
     * @param className Fully qualified class name
     * @param methodNames List of method names to generate .jpf files for
     * @param outputDir Directory where to save .jpf files (null = current directory)
     * @param classpath JPF classpath
     * @param sourcepath JPF sourcepath
     * @param javaCode Optional Java code to extract method signatures from
     * @return List of generated .jpf file paths
     * @throws IOException If file writing fails
     */
    public List<String> generateJpfFilesForMethods(String className, List<String> methodNames, 
                                                    String outputDir, String classpath, String sourcepath,
                                                    String javaCode) 
            throws IOException {
        List<String> generatedFiles = new ArrayList<>();
        String simpleClassName = className.substring(className.lastIndexOf('.') + 1);
        
        for (String methodName : methodNames) {
            String jpfFileName = simpleClassName + "_" + methodName + ".jpf";
            String outputPath = (outputDir != null && !outputDir.isEmpty()) 
                ? Paths.get(outputDir, jpfFileName).toString() 
                : jpfFileName;
            
            generateJpfFile(className, methodName, outputPath, classpath, sourcepath, javaCode);
            generatedFiles.add(outputPath);
        }
        
        return generatedFiles;
    }
    
    /**
     * Generates .jpf files for all test methods in an AtcClass.
     * This is a convenience method that extracts class info from AtcClass.
     * 
     * @param atcClass The AtcClass IR object
     * @param outputDir Directory where to save .jpf files (null = current directory)
     * @param classpath JPF classpath (null = use default)
     * @param sourcepath JPF sourcepath (null = use default)
     * @param javaCode Optional Java code to extract method signatures from
     * @return List of generated .jpf file paths
     * @throws IOException If file writing fails
     */
    public List<String> generateJpfFilesFromAtcClass(AtcClass atcClass, String outputDir, 
                                                     String classpath, String sourcepath, String javaCode) 
            throws IOException {
        String fullClassName = atcClass.getPackageName() + "." + atcClass.getClassName();
        List<String> methodNames = new ArrayList<>();
        
        for (AtcTestMethod method : atcClass.getTestMethods()) {
            methodNames.add(method.getMethodName());
        }
        
        return generateJpfFilesForMethods(fullClassName, methodNames, outputDir, classpath, sourcepath, javaCode);
    }
}
